/*! Timeline
 *Copyright (C) 2021 Aonghus Storey
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
!function(t,s){"object"==typeof exports&&"undefined"!=typeof module?module.exports=s():"function"==typeof define&&define.amd?define(s):(t="undefined"!=typeof globalThis?globalThis:t||self).Timeline=s()}(this,(function(){"use strict";const t="http://www.w3.org/2000/svg";class s{static draw({start:s,end:i,stroke:o,colour:e,markers:r=[],dashes:n="",title:h=""}={}){const c=2*o,l=i.x-s.x,a=i.y-s.y,d={x1:c,y1:c,x2:l+c,y2:a+c};i.x<s.x&&(d.x1+=Math.abs(l),d.x2+=Math.abs(l)),i.y<s.y&&(d.y1+=Math.abs(a),d.y2+=Math.abs(a));const u=Math.min(s.x,i.x)-c,f=Math.min(s.y,i.y)-c;let m=document.createElementNS(t,"svg");m.setAttribute("width",Math.abs(l)+2*c),m.setAttribute("height",Math.abs(a)+2*c),m.setAttribute("style","position: absolute; left: "+u+"px; top: "+f+"px");const w=this.drawLine(d,e,o,n,h);return w.setAttribute("data-coords",`[ ${s.x}, ${s.y} ], [ ${i.x}, ${i.y} ]`),m.append(w),m=this.t(m,r[0],"start",d,o,e),m=this.t(m,r[1],"end",d,o,e),m}static t(t,s,i,o,e,r){return"circle"==s&&t.append(this.i(i,o,e,r)),"square"==s&&t.append(this.o(i,o,e,r)),"dots"==s&&"end"==i&&(t.setAttribute("width",parseInt(t.getAttribute("width"))+2*e),t.append(this.h(o,e,r))),t}static o(t,s,i,o){let[e,r]=[s.x1-i,s.y1-i];return"end"==t&&([e,r]=[s.x2-i,s.y2-i]),this.drawSquare(e,r,2.5*i,o)}static i(t,s,i,o){let[e,r]=[s.x1,s.y1];return"end"==t&&([e,r]=[s.x2,s.y2]),this.drawCircle(e,r,i,o)}static h(t,s,i){let o=t.x2;t.x2<t.x1&&(o=t.x2-5*s),t.x2>t.x1&&(o=t.x2+5*s);let e=t.y2;t.y2<t.y1&&(e=t.y2-2*s),t.y2>t.y1&&(e=t.y2+2*s);const r={x1:t.x2,y1:t.y2,x2:o,y2:e};return this.drawLine(r,i,s,`0 ${s} ${s} ${s} ${s}`)}static drawLine(s,i,o,e="",r=""){const n=document.createElementNS(t,"line");return n.setAttribute("x1",s.x1),n.setAttribute("y1",s.y1),n.setAttribute("x2",s.x2),n.setAttribute("y2",s.y2),n.setAttribute("stroke",i),n.setAttribute("stroke-width",o),n.setAttribute("stroke-dasharray",e),r&&n.append(this.l(r)),n}static drawCircle(s,i,o,e,r=""){const n=document.createElementNS(t,"circle");return n.setAttribute("cx",s),n.setAttribute("cy",i),n.setAttribute("r",o),n.setAttribute("fill",e),r&&n.append(this.l(r)),n}static drawSquare(s,i,o,e,r=""){const n=document.createElementNS(t,"rect");return n.setAttribute("x",s),n.setAttribute("y",i),n.setAttribute("width",o),n.setAttribute("height",o),n.setAttribute("fill",e),r&&n.append(this.l(r)),n}static l(s){const i=document.createElementNS(t,"title");return i.append(document.createTextNode(s)),i.dataset.title=s,i}}class i{u;m;p;$;g;_;constructor(t,s,i){this.u=t,this.m=this.k(t),this.$=s,this.g=i,this._=i-s+1,this.p=this.v(this.m),this.C(),this.I(),console.log(this.S),console.log(this.m)}I(){for(const t of this.m)if(t.ids)for(const s of t.ids)document.getElementById(s).dataset.row=t.row;else document.getElementById(t.id).dataset.row=t.row}C(){this.S=[];for(let t of this.m.filter((t=>t.cluster)))t=this.M(t);for(;this.m.find((t=>t.cluster&&isNaN(t.row)));)this.R(this.N(this.m.find((t=>t.cluster&&isNaN(t.row)))));for(const t of this.S.reverse())this.A(this.F("id",t)[0]);console.log("Left over:");for(const t of this.m.filter((t=>void 0===t.row))){const s=this.G(t.start,t.end);this.P(s,t),console.log(`${t.id}: ${s}`)}for(const t of this.m){t.deviation=0;for(const s in t.relativeRows)t.relativeRows[s].actual=t.row-this.F("id",s)[0].row,t.deviation+=Math.abs(t.relativeRows[s].relative-t.relativeRows[s].actual)}}R(t){let s=!1;if("G"==t.id&&(s=!0),this.S.push(t.id),console.log(`${t.id}: root is ${this.N(t).id}`),void 0===t.grid)throw new Error(`Tried to position ${t.id} without a calculated group grid.`);let i=this.T(t);if(console.log(`Group: ${t.id}`),console.log(`${t.id} grid check: ${JSON.stringify(i)}`),!i.fit&&t.row){for(;null!==i.row&&t.grid.length+i.row>this.p.length;)this.q();i=this.T(t),i=this.B(t),console.log(`${t.id} forced: ${JSON.stringify(i)}`)}if(i.fit||(this.D(i.count,1,t),i=this.T(t),console.log(`${t.id} shunted at ${i.count}. Check: ${JSON.stringify(i)}`)),i.fit)for(const o of t.cluster){s&&console.log(`Existing row for ${o.id}: ${o.row}`),console.log(i);const e=o.row?o.row:i.row+o.relativeRows[t.id].row;console.log(`${o.id}: ${e}`),o.row!==e&&this.P(e,o),o.cluster&&(o.anchor=e)}for(const s of t.cluster.filter((s=>{if(s!==t&&s.cluster&&s.cluster.map((t=>!t.row)).length>0)return!0})))console.log(`${t.id}: Moving to linked cluster ${s.id}`),this.R(s)}N(t){let s=t;console.log(`Following chain for ${t.id}`);const i=this.F("cluster",t).filter((s=>s.id!==t.id));console.log(i);for(const o of i){if(o.id==t.merge&&t.split&&!o.cluster.includes(this.F("id",t.split))){console.log("Choosing split branch to recurse");break}s=this.N(o)}return console.log(`${t.id} chains with ${s.id}`),s}M(t){let s=this.v(t.cluster),i=this.O(s);const o=s.length-i.length;t.grid=i;for(const s of t.cluster.filter((t=>t.row)))t.rowTemp=s.row-parseInt(o);void 0===t.rowTemp&&(t.rowTemp=this.G(t.start,t.end,t),t.grid=this.J(t.rowTemp,this.W(t.start),this.W(t.end),t.grid));let e=t.cluster.filter((s=>s.merge==t.id||s.split==t.id));e.sort(((s,i)=>(s.split==t.id?s.start:s.merge)-(i.split==t.id?i.start:i.merge)));for(const t of e);for(const s of t.cluster.filter((t=>void 0===t.rowTemp))){let i=this.G(s.start,s.end,t);t.grid=this.J(i,this.W(s.start),this.W(s.end),t.grid),s.rowTemp=i}for(const s of t.cluster){const i=s.relativeRows||{};i[t.id]={row:s.rowTemp,relative:s.rowTemp-t.rowTemp},s.relativeRows=i}for(const s of t.cluster)delete s.rowTemp;return t}k(t){let s=[...t].map((t=>{let s={id:t.id};for(const i in t.dataset){let o=t.dataset[i].split(" ").length>1?t.dataset[i].split(" "):t.dataset[i];isNaN(o)||(o=parseInt(o)),s[i]=o}return s}));for(const t of s.filter((t=>t.become)).sort(((t,s)=>t.start-s.start)))if(s.includes(t)){const i=this.L(t,s);s.splice(s.indexOf(t),1,i);for(const[t,o]of i.ids.entries())if(t>0){const t=s.findIndex((t=>t.id==o));s.splice(t,1)}}for(let t of s.filter((t=>t.merge)).concat(s.filter((t=>t.split))))t=this.H(t,s);for(const t of s){const i=this.j(t,s);i.length>1&&(t.cluster=i)}return s}L(t,s){t={...t};let i={...s.find((s=>s.ids?s.ids.includes(t.become):s.id===t.become))};return i.become&&(i=this.L(i,s)),t.ids=i.ids?[].concat(t.id,i.ids):[].concat(t.id,i.id),t.chain=!0,t.end=i.end,delete t.become,i.merge&&(t.merge=i.merge),t}H(t,s){const i=["merge","split"];for(const o of i)t[o]&&0===this.F("id",t[o],s).length&&(t[o]=this.F("ids",t[o],s)[0].id);return t}j(t,s){let i=[t];return i=i.concat(this.F("split",t.id,s)),i=i.concat(this.F("merge",t.id,s).filter((s=>t.split!==s.id&&s.end!==t.start))),i=i.concat(this.F("id",t.merge,s).filter((s=>s.start==t.end))),i}F(t,s,i=this.m){return i.filter((i=>!!i[t]&&(Array.isArray(i[t])?i[t].includes(s):i[t]===s)))}V(t,s,i=this.m){if(!s)throw new Error(`Find by values called without values: ${t} ${s}`);let o=[];for(const e of s)o=o.concat(this.F(t,e,i));return o}X(t,s=this.m){for(const s in t)"string"==typeof t[s]&&(t[s]=[t[s]]);for(const s of["all","any","none"])t[s]||(t[s]=[]);return s.filter((s=>t.all.every((t=>s[t]))&&t.none.every((t=>!s[t]))&&t.any.some((t=>s[t]))))}D(t,s,i){if(0===s)return t;const o=Array.from(Array(s),(()=>new Array(this._).fill(!1)));i.grid.splice(t,0,...o);for(const o of i.cluster.filter((t=>t.rowTemp||t.relativeRows)))void 0===o.rowTemp&&o.relativeRows.hasOwnProperty(i.id)&&(o.rowTemp=o.relativeRows[i.id].row),o.rowTemp>=t&&(o.rowTemp=o.rowTemp+s),o.relativeRows&&o.relativeRows[i.id]&&(o.relativeRows[i.id].row=o.rowTemp,delete o.rowTemp);return t}P(t,s){s.row&&this.Y(s.row,this.W(s.start),this.W(s.end),this.p),s.row=t,this.J(t,this.W(s.start),this.W(s.end),this.p)}K(t,s){s.rowTemp=t,s.grid=this.J(t,this.W(s.start),this.W(s.end),s.grid)}G(t,s,i){let o=i?i.grid:this.p,e=this.U(this.W(t),this.W(s),0,null,o);return e||0===e||(o=this.q(o),e=o.length-1),e}T(t){let s=!1;for("C"==t.id&&(s=!0),s&&console.log(`Cluster grid: ${this.Z(t.grid)}`),s&&console.log(`Master grid: ${this.Z(this.p)}`);this.p.length<t.grid.length;)this.p=this.q();for(const s of t.cluster.filter((t=>t.row)))this.Y(s.relativeRows[t.id].row,this.W(s.start),this.W(s.end),t.grid);const i=t.row?t.row-t.relativeRows[t.id].row:null;let o=this.tt(t.grid,this.p,i);for(;o.row>0&&this.p.length<t.grid.length+o.row;)this.q(),console.log("Adding row to master grid");o=this.tt(t.grid,this.p,i);const e=this.p.length+t.grid.length;for(;null==o.row&&!t.row&&this.p.length<e;)this.q();o=this.tt(t.grid,this.p,i);const r=this.tt(t.grid,this.p,i);null!==i&&!1===o.fit&&(o.alternative=r),s&&console.log(o);for(const s of t.cluster.filter((t=>t.row)))this.J(s.relativeRows[t.id].row,this.W(s.start),this.W(s.end),t.grid);return o}B(t,s){if(void 0===s&&!t.row)throw new Error(`Cannot force position without a row: ${t.id}`);void 0===s&&(s=t.row),console.log(`Working through group to force insert: ${t.id}.`);const i=1*s-t.relativeRows[t.id].row;if(!t.row){const i=this.st(s,t);console.log(i)}for(const s of t.cluster.filter((s=>s.relativeRows[t.id].row<t.relativeRows[t.id].row))){const o=1*s.relativeRows[t.id].row+1*i,e=this.st(o,s);console.log(e)}for(const s of t.cluster.filter((s=>s.relativeRows[t.id].row>t.relativeRows[t.id].row))){const o=1*s.relativeRows[t.id].row+1*i,e=this.st(o,s);console.log(e)}return this.A(t),{fit:!0,row:s-=t.relativeRows[t.id].row,count:t.grid.length}}it(t,s){return s=s.splice(t,0,new Array(this._).fill(!1)),t}A(t){for(const s of t.cluster.filter((s=>s!==t.id))){const i=this.ot(s,t.id);i?(console.log(`Moving ${s.id} to ${i}.`),this.P(i,s)):console.log(`No better place for ${s.id}`)}}ot(t){let s=0;if(!t.row)return!1;for(const i in t.relativeRows){const o=this.F("id",i)[0];o.row&&(console.log(`${t.id} would like to be at ${o.row+t.relativeRows[i].relative}`),s+=o.row+t.relativeRows[i].relative-t.row)}console.log(`${t.id} is at ${t.row}; preference: ${s}`);return this.U(this.W(t.start),this.W(t.end),s>0?t.row:t.row+s,s>0?t.row+s:t.row)}tt(t,s,i=null){let o=0;const e=i;let r=[];if(null!==i&&this.et(t[0],s[i])){o=1;for(let e=1;e<t.length&&s[i+e]&&this.et(t[e],s[i+e]);e++)o+=1;return{fit:o===t.length,row:i,count:o,requested:e,log:r}}for(const[n,h]of s.entries())if(this.et(t[0],h)){i=n,o=1;for(let e=1;e<t.length&&e+i<s.length;e++){const n=this.et(t[e],s[i+e]);if(n&&r.push(`${e}: Fit ok for row ${i+e}`),!n)break;o+=1}return{fit:o===t.length,row:i,count:o,requested:e}}return{fit:!1,row:null,count:0,requested:e}}et(t,s){for(const[i,o]of t.entries())if(o&&s[i])return!1;return!0}U(t,s,i=0,o=null,e=this.p){null===o&&(o=e.length-1);for(let r=i;r<=o;r++)if(this.rt(r,t,s,e))return r;return!1}rt(t,s,i,o=this.p){if(s===i&&(i+=1),void 0===o[t])throw new Error(`Invalid row checked. ${t} ${s} ${i}. Highest row: ${o.length-1}`);if(i>o[t].length-1||s<0)throw new Error(`Invalid range checked. ${t} ${s} ${i}. Available range is: 0 - ${o[t].length-1}`);return o[t].slice(s,i).every((t=>!1===t))}get rows(){return this.p.length}v(t){const s=t.filter((t=>t.row)),i=s.length>0?Math.max(...s.map((t=>t.row)))+1:1;let o=Array.from(Array(i),(()=>new Array(this._).fill(!1)));for(const t of s)o=this.J(t.row,this.W(t.start),this.W(t.end),o);return o}O(t){let s=0;for(;s<t.length-1&&this.rt(s,0,t[0].length-1,t);)s++;return t=t.slice(s)}Z(t){return JSON.stringify(t.map((t=>t.filter((t=>t)).length)))}J(t,s,i,o=this.p){return this.nt(t,s,i,!0,o),o}Y(t,s,i,o=this.p){return this.nt(t,s,i,!1,o),o}nt(t,s,i,o,e=this.p){if(!e[t])throw new Error(`Attempt to mark non-existent grid row ${t}`);if(s>e[0].length-1||i>e[0].length-1)throw new Error(`X coords out of range: ${s} ${i}`);let r=0;for(;r<i-s;)e[t][s+r]=o,r++;return s>0&&(e[t][s-1]=o),i<e[t].length&&(e[t][i]=o),e}q(t=this.p){return t.push(new Array(this._).fill(!1)),t}st(t,s,i=this.p){let o=Array();return s.row==t?(console.log(`Requested to free row ${t} for ${s.id} but it's already positioned there...`),o):(this.rt(t,this.W(s.start),this.W(s.end),i)||(console.log(`Row ${t} not free for ${s.id}. Shifting.`),o=this.ht(parseInt(t),this.W(s.start),this.W(s.end),i)),o)}ht(t,s,i,o){let e=Array();console.log(`Shift called with: ${t} ${s} ${i}`);const r=this.m.filter((o=>o.row==t&&this.W(o.end)>=s&&this.W(o.start)<=i));console.log("Entries affected:"),console.log(r);for(const s of r){console.log(`${s.id} affected by move at row ${t}`);const i=this.W(s.start),r=this.W(s.end);1*t+1>=o.length&&this.q(o);let n=!1;this.rt(1*t+1,i,r,o)&&(n=!0),!1===n&&(console.log(`Space for ${s.id} was blocked. Continuing...`),e=e.concat(this.ht(1*t+1,i,r,o))),this.P(1*s.row+1,s),e.push(s.id),console.log(`${s.id} moving from ${1*s.row-1} to ${s.row}`)}return e}ct(t,s=this.p){s==this.p&&console.log(`Inserting row in master grid at ${t}`);try{s.splice(t,0,new Array(this._).fill(!1))}catch{throw new Error(`Bad row insert: ${t}, ${count}`)}return s}W(t){if(isNaN(t))throw new Error(`${t} is not a year. Cannot parse as number.`);return parseInt(t)-parseInt(this.$)}}function o(t,s){let i={};for(const o in t)s.hasOwnProperty(o)?i[o]=s[o]:i[o]=t[o];return i}const e={yearStart:1900,yearEnd:(new Date).getFullYear()+1,strokeWidth:4,yearWidth:50,rowHeight:50,padding:5,strokeColour:"#999",boxWidth:100,guides:!0,guideInterval:5,entrySelector:"div",linkDashes:"4",irregularDashes:"88 4 4 4"};class r{constructor(t,s={}){this.lt=this.dt(s),this.ut=document.getElementById(t),this.m=this.ut.querySelectorAll("#"+t+" > "+this.lt.entrySelector+":not(.timeline-exclude)"),this.ft()}ft(){let t=1;for(const s of this.m)s.classList.contains("timeline-block")?(s.id="block-"+t,s.dataset.block=!0,t++):(s.classList.add("entry"),s.dataset.entry=!0),s.dataset.end=s.dataset.end?s.dataset.end:this.lt.yearEnd,s.dataset.become&&(s.dataset.end=parseInt(document.getElementById(s.dataset.become).dataset.start))}dt(t){const s=o(e,t);return s.boxHeight=s.rowHeight-2*s.padding,s.boxMinWidth=s.boxHeight,s}wt(t,s){this.lt[t]=s}create(){return this.$t=new i(this.m,this.lt.yearStart,this.lt.yearEnd),this.wt("rows",this.$t.rows),this.gt(),this.yt(),this._t(),!0===this.lt.guides&&this.xt(),this.ut}gt(){const t=document.documentElement;t.style.setProperty("--timeline-year-width",this.lt.yearWidth+"px"),t.style.setProperty("--timeline-row-height",this.lt.rowHeight+"px"),t.style.setProperty("--timeline-box-width",this.lt.boxWidth+"px"),t.style.setProperty("--timeline-box-height",this.lt.boxHeight+"px"),t.style.setProperty("--timeline-box-width-min",this.lt.boxHeight+"px"),t.style.setProperty("--timeline-padding",this.lt.padding+"px"),t.style.setProperty("--timeline-stroke-colour",this.lt.strokeColour),this.ut.classList.add("timeline-container"),this.ut.style.height=(this.lt.rows+2)*this.lt.rowHeight+"px",this.ut.style.width=(this.lt.yearEnd+1-this.lt.yearStart)*this.lt.yearWidth+"px",this.kt()}kt(){for(const t of this.m)t.style.left=this.vt(t.dataset.start)+"px",t.style.top=(parseInt(t.dataset.row)+1)*this.lt.rowHeight+this.lt.padding+"px",t.dataset.colour&&(t.style.borderColor=t.dataset.colour),!0===this.Et(t)&&t.classList.add("min");for(const t of[...this.m].filter((t=>t.dataset.become))){const s=document.getElementById(t.dataset.become);t.dataset.start==s.dataset.start&&(t.style.left=parseInt(t.style.left)-this.lt.boxMinWidth/2+"px",s.style.left=parseInt(s.style.left)+this.lt.boxMinWidth/2+"px")}}_t(){const t=document.createElement("div");t.classList.add("dates");let s=this.lt.yearStart;for(;s<this.lt.yearEnd;){const i=document.createElement("date");i.style.left=this.vt(s)+"px";const o=document.createTextNode(s);i.append(o),t.append(i),s+=5}this.ut.prepend(t);const i=t.cloneNode(!0);i.style.top=this.lt.rows*this.lt.rowHeight+"px",this.ut.append(i)}xt(){let t=this.lt.yearStart;for(;t<Math.ceil(this.lt.yearEnd/this.lt.guideInterval)*this.lt.guideInterval;){const s=document.createElement("div");s.classList.add("guide"),s.style.left=this.vt(t)+"px",s.style.width=this.lt.yearWidth*this.lt.guideInterval+"px",(t-this.lt.yearStart)/this.lt.guideInterval%2==1&&s.classList.add("odd"),this.ut.append(s),t+=this.lt.guideInterval}}yt(){for(const t of[...this.m].filter((t=>!t.classList.contains("timeline-block")))){const i=t.dataset.colour?t.dataset.colour:this.lt.strokeColour,o="true"==t.dataset.irregular?this.lt.irregularDashes:"";if(!t.id)throw new Error(`Missing id on ${t.text}`);try{this.vt(t.dataset.end)}catch{console.log(`${t.id} error on draw - bad end year`)}let e="",r="end",n=this.bt(t.id,"right"),h={x:this.vt(t.dataset.end),y:n.y};if(t.dataset.merge||t.dataset.become||(e=t.dataset.endEstimate?"dots":"circle"),t.dataset.become&&(h=this.bt(t.dataset.become,"left"),r="become"),t.dataset.merge){t.dataset.start==t.dataset.end&&(h.x+=this.lt.yearWidth);const o={x:h.x,y:this.Ct(t.dataset.merge)};h.x=h.x-this.lt.yearWidth;const e=s.draw({start:h,end:o,stroke:this.lt.strokeWidth,colour:i});e.classList.add("merge"),this.ut.append(e),r="merge"}if(t.dataset.start!==t.dataset.end){const t=s.draw({start:n,end:h,stroke:this.lt.strokeWidth,colour:i,markers:["",e],dashes:o});t.classList.add(r),this.ut.append(t)}t.dataset.split&&this.It(t,i),t.dataset.links&&this.St(t,i)}}It(t,i){const o=document.getElementById(t.dataset.split);let e="top";parseInt(t.dataset.row)<parseInt(o.dataset.row)&&(e="bottom");const r={x:this.vt(t.dataset.start),y:this.Ct(o.id)};o.dataset.end<=t.dataset.start&&(console.log(`Former start ${r.x}`),r.x=r.x-this.lt.yearWidth,console.log(`New start ${r.x}`),e="left");const n=this.bt(t.id,e),h=s.draw({start:r,end:n,stroke:this.lt.strokeWidth,colour:i});h.classList.add("split"),this.ut.append(h)}St(t,i){const o=t.dataset.links.split(" ");let e={top:-1,bottom:-1,left:-1,right:-1};for(const r of o){const o=document.getElementById(r);o||console.warn(`${t.id} links to non-existant ID ${r}`);let n,h,c={x:0,y:0},l={x:0,y:0};const a=parseInt(t.dataset.row),d=parseInt(o.dataset.row);a===d&&t.dataset.start<o.dataset.start&&(e.right=e.right+1,n="right",h="left"),a===d&&t.dataset.start>o.dataset.start&&(e.left=e.left+1,n="left",h="right"),a>d&&(e.top=e.top+1,n="top",h="bottom"),a<d&&(e.bottom=e.bottom+1,n="bottom",h="top"),c=this.bt(t.id,n,e[n]),l={x:c.x,y:this.Ct(o.id)},t.dataset.start>=o.dataset.end&&(l.x=this.vt(o.dataset.end)),t.dataset.start==o.dataset.start&&(l=this.bt(o.id,h));const u=s.draw({start:c,end:l,stroke:this.lt.strokeWidth/2,colour:i,markers:["square","square"],dashes:this.lt.linkDashes});u.classList.add("link"),this.ut.append(u)}}Et(t){return(t.dataset.end-t.dataset.start>0?t.dataset.end-t.dataset.start:1)<this.lt.boxWidth/this.lt.yearWidth}zt(t){const s=document.getElementById(t);return parseFloat(s.style.left)+this.lt.boxWidth/2}Ct(t){const s=document.getElementById(t);return null==s&&console.log(`ID:${t} got null node.`),parseFloat(s.style.top)+this.lt.boxHeight/2}bt(t,s,i=0){const o=document.getElementById(t),e=window.getComputedStyle(o),r=parseFloat(o.style.left),n=parseFloat(o.style.top),h=parseFloat(e.getPropertyValue("width")),c=parseFloat(e.getPropertyValue("height"));switch(s){case"left":return{x:r,y:n+c/2+5*i};case"right":return{x:r+h,y:n+c/2+5*i};case"top":return{x:r+h/2+5*i,y:n};case"bottom":return{x:r+h/2+5*i,y:n+c};default:throw`Invalid element side specified: Called with ${s}. Entry: ${t}`}}vt(t){if(isNaN(t))throw new Error(`Non-numerical year value received: ${t}`);return parseInt((t-this.lt.yearStart)*this.lt.yearWidth)}}const n={panzoom:!1,findForm:"timeline-find",zoomIn:"timeline-zoom-in",zoomOut:"timeline-zoom-out",zoomReset:"timeline-zoom-reset"};return class{constructor(t="diagram",s={}){this.ut=t,this.Mt(s)}create(){const t=new r(this.ut,this.Rt);this.Nt=t.create(),!0===this.lt.panzoom&&(this.At(),this.Ft(),window.addEventListener("hashchange",(()=>this.Gt()))),location.hash&&setTimeout((()=>{this.Gt()}))}Mt(t){this.lt=o(n,t),this.Rt=o(e,t)}panToEntry(t){if(!0!==this.lt.panzoom)throw new Error("Panzoom not enabled. Enable Panzoom to use the pan-to-entry feature.");if(void 0===this.Pt)throw new Error("Panzoom module missing. Include Panzoom to use the pan-to-entry feature.");const s=document.getElementById(t),i=window.innerWidth/2-parseInt(s.style.left)-this.Rt.boxWidth/2,o=window.innerHeight/2-parseInt(s.style.top)-this.Rt.rowHeight/2;this.Pt.zoom(1),this.Pt.pan(i,o);const e=new CustomEvent("timelineFind",{detail:{id:t,name:s.innerText}});document.getElementById(this.ut).dispatchEvent(e),setTimeout((()=>{s.classList.add("highlight","hover")}),500),setTimeout((()=>{s.classList.remove("highlight","hover")}),2e3)}Ft(){const t=document.getElementById(this.lt.zoomIn),s=document.getElementById(this.lt.zoomOut),i=document.getElementById(this.lt.zoomReset),o=document.getElementById(this.lt.findForm);t&&t.addEventListener("click",this.Pt.zoomIn),s&&s.addEventListener("click",this.Pt.zoomOut),i&&i.addEventListener("click",(()=>this.Pt.zoom(1))),o&&this.Tt(o)}Tt(t){const s=document.createElement("input");s.name="find-id",s.style.display="none",t.append(s);const i=t.querySelector("input[name=finder]"),o=document.createElement("div"),e=document.createElement("div"),r=document.createElement("ul");o.classList.add("filtered-entries"),o.appendChild(e),e.appendChild(r),i.parentNode.insertBefore(o,i),o.appendChild(i),i.autocomplete="off",e.style.width=i.offsetWidth+"px";const n={form:t,finder:i,id:s,results:r};this.qt=n,n.finder.value="",t.addEventListener("input",(t=>this.Bt(t))),t.addEventListener("submit",(t=>this.Dt(t))),r.addEventListener("click",(t=>this.Ot(t)))}Bt(t){const s=t.target.value;if(""===s.trim())return void(this.qt.results.innerHTML="");const i=this.Jt(s),o=this.qt.results;o.innerHTML="";for(const t of i){const s=document.createElement("li");s.dataset.id=t.id,s.innerText=t.name,o.append(s)}}Jt(t){return[...document.querySelectorAll(".entry")].map((t=>({id:t.id,name:t.innerText}))).filter((s=>s.name.toLowerCase().includes(t.toLowerCase())))}Ot(t){if("li"!==t.target.localName)return null;const s=this.qt.form,i=this.qt.finder,o=this.qt.id;i.value=t.target.innerText,o.value=t.target.dataset.id,s.requestSubmit()}Dt(t){t.preventDefault();const s=t.target.querySelector("input[name=find-id]").value;t.target.querySelector("input[name=finder]").value,document.getElementById(s)&&this.panToEntry(s),this.qt.results.innerHTML="",this.qt.finder.value=""}At(){if("undefined"==typeof Panzoom)throw new Error("Missing dependency. External Panzoom library (@panzoom/panzoom) is required to use the panzoom feature.");const t=document.createElement("div");t.classList.add("pz-wrap"),this.Nt.parentNode.insertBefore(t,this.Nt),t.appendChild(this.Nt),this.Pt=Panzoom(this.Nt,{contain:"outside",maxScale:3,minScale:.5,step:.1,handleStartEvent:t=>{t.preventDefault()}}),this.Nt.parentElement.addEventListener("wheel",this.Pt.zoomWithWheel)}Gt(){const t=location.hash.replace("#find-","");document.getElementById(t)&&this.Pt&&this.panToEntry(t)}}}));
