/*! Timeline
 *Copyright (C) 2021 Aonghus Storey
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?module.exports=i():"function"==typeof define&&define.amd?define(i):(t="undefined"!=typeof globalThis?globalThis:t||self).Timeline=i()}(this,(function(){"use strict";const t="http://www.w3.org/2000/svg";class i{static draw({start:i,end:s,stroke:e,colour:o,markers:r=[],dashes:n="",title:h=""}={}){const c=2*e,a=s.x-i.x,l=s.y-i.y,d={x1:c,y1:c,x2:a+c,y2:l+c};s.x<i.x&&(d.x1+=Math.abs(a),d.x2+=Math.abs(a)),s.y<i.y&&(d.y1+=Math.abs(l),d.y2+=Math.abs(l));const u=Math.min(i.x,s.x)-c,f=Math.min(i.y,s.y)-c;let m=document.createElementNS(t,"svg");m.setAttribute("width",Math.abs(a)+2*c),m.setAttribute("height",Math.abs(l)+2*c),m.setAttribute("style","position: absolute; left: "+u+"px; top: "+f+"px");const w=this.drawLine(d,o,e,n,h);return w.setAttribute("data-coords",`[ ${i.x}, ${i.y} ], [ ${s.x}, ${s.y} ]`),m.append(w),m=this.t(m,r[0],"start",d,e,o),m=this.t(m,r[1],"end",d,e,o),m}static t(t,i,s,e,o,r){return"circle"==i&&t.append(this.i(s,e,o,r)),"square"==i&&t.append(this.o(s,e,o,r)),"dots"==i&&"end"==s&&(t.setAttribute("width",parseInt(t.getAttribute("width"))+2*o),t.append(this.h(e,o,r))),t}static o(t,i,s,e){let[o,r]=[i.x1-s,i.y1-s];return"end"==t&&([o,r]=[i.x2-s,i.y2-s]),this.drawSquare(o,r,2.5*s,e)}static i(t,i,s,e){let[o,r]=[i.x1,i.y1];return"end"==t&&([o,r]=[i.x2,i.y2]),this.drawCircle(o,r,s,e)}static h(t,i,s){let e=t.x2;t.x2<t.x1&&(e=t.x2-5*i),t.x2>t.x1&&(e=t.x2+5*i);let o=t.y2;t.y2<t.y1&&(o=t.y2-2*i),t.y2>t.y1&&(o=t.y2+2*i);const r={x1:t.x2,y1:t.y2,x2:e,y2:o};return this.drawLine(r,s,i,`0 ${i} ${i} ${i} ${i}`)}static drawLine(i,s,e,o="",r=""){const n=document.createElementNS(t,"line");return n.setAttribute("x1",i.x1),n.setAttribute("y1",i.y1),n.setAttribute("x2",i.x2),n.setAttribute("y2",i.y2),n.setAttribute("stroke",s),n.setAttribute("stroke-width",e),n.setAttribute("stroke-dasharray",o),r&&n.append(this.l(r)),n}static drawCircle(i,s,e,o,r=""){const n=document.createElementNS(t,"circle");return n.setAttribute("cx",i),n.setAttribute("cy",s),n.setAttribute("r",e),n.setAttribute("fill",o),r&&n.append(this.l(r)),n}static drawSquare(i,s,e,o,r=""){const n=document.createElementNS(t,"rect");return n.setAttribute("x",i),n.setAttribute("y",s),n.setAttribute("width",e),n.setAttribute("height",e),n.setAttribute("fill",o),r&&n.append(this.l(r)),n}static l(i){const s=document.createElementNS(t,"title");return s.append(document.createTextNode(i)),s.dataset.title=i,s}}class s{u;m;p;$;g;_;constructor(t,i,s){this.u=t,this.m=this.k(t),this.$=i,this.g=s,this._=s-i+1,this.p=this.v(this.m),this.I(),this.R(),console.log(this.S),console.log(this.m)}R(){for(const t of this.m)if(t.ids)for(const i of t.ids)document.getElementById(i).dataset.row=t.row;else document.getElementById(t.id).dataset.row=t.row}I(){this.S=[];for(let t of this.m.filter((t=>t.related)))t=this.M(t);for(;this.m.find((t=>t.related&&isNaN(t.row)));)this.C(this.G(this.m.find((t=>t.related&&isNaN(t.row)))));for(const t of this.S.reverse())this.F(this.N("id",t)[0]);console.log("Left over:");for(const t of this.m.filter((t=>void 0===t.row))){const i=this.A(t.start,t.end);this.P(i,t),console.log(`${t.id}: ${i}`)}for(const t of this.m){t.deviation=0;for(const i in t.relativeRows)t.relativeRows[i].actual=t.row-this.N("id",i)[0].row,t.deviation+=Math.abs(t.relativeRows[i].relative-t.relativeRows[i].actual)}}C(t){let i=!1;if("G"==t.id&&(i=!0),this.S.push(t.id),console.log(`${t.id}: root is ${this.G(t).id}`),void 0===t.grid)throw new Error(`Tried to position ${t.id} without a calculated group grid.`);let s=this.T(t);if(console.log(`Group: ${t.id}`),console.log(`${t.id} grid check: ${JSON.stringify(s)}`),!s.fit&&t.row){for(;null!==s.row&&t.grid.length+s.row>this.p.length;)this.q();s=this.T(t),s=this.B(t),console.log(`${t.id} forced: ${JSON.stringify(s)}`)}if(s.fit||(this.D(s.count,1,t),s=this.T(t),console.log(`${t.id} shunted at ${s.count}. Check: ${JSON.stringify(s)}`)),s.fit)for(const e of t.related){i&&console.log(`Existing row for ${e.id}: ${e.row}`),console.log(s);const o=e.row?e.row:s.row+e.relativeRows[t.id].row;console.log(`${e.id}: ${o}`),e.row!==o&&this.P(o,e),e.related&&(e.anchor=o)}for(const i of t.related.filter((i=>{if(i!==t&&i.related&&i.related.map((t=>!t.row)).length>0)return!0}))){if(t.fork&&t.fork.includes(i.id)&&i.start<t.start){console.log(`Skipping fork to earlier entry ${i.id}`);break}console.log(`${t.id}: Moving to linked group ${i.id}`),this.C(i)}}G(t){let i=t;console.log(`Following chain for ${t.id}`);const s=this.N("related",t).filter((i=>i.id!==t.id));console.log(s);for(const e of s){if(e.fork&&Math.min(...this.O("id",e.fork).map((t=>t.start)))>t.start)break;if(e.id==t.merge&&t.split&&!e.related.includes(this.N("id",t.split))){console.log("Choosing split branch to recurse");break}i=this.G(e)}return console.log(`${t.id} chains with ${i.id}`),i}M(t){let i=this.v(t.related),s=this.J(i);const e=i.length-s.length;t.grid=s;for(const i of t.related.filter((t=>t.row)))t.rowTemp=i.row-parseInt(e);void 0===t.rowTemp&&(t.rowTemp=this.A(t.start,t.end,t),t.grid=this.W(t.rowTemp,this.L(t.start),this.L(t.end),t.grid)),this.H(t);let o=t.related.filter((i=>i.merge==t.id||i.split==t.id));o.sort(((i,s)=>(i.split==t.id?i.start:i.merge)-(s.split==t.id?s.start:s.merge)));for(const t of o);for(const i of t.related.filter((t=>void 0===t.rowTemp))){let s=this.A(i.start,i.end,t);t.grid=this.W(s,this.L(i.start),this.L(i.end),t.grid),i.rowTemp=s}for(const i of t.related){const s=i.relativeRows||{};s[t.id]={row:i.rowTemp,relative:i.rowTemp-t.rowTemp},i.relativeRows=s}for(const i of t.related)delete i.rowTemp;return t}H(t){if(!t.fork)return;const i=this.N("id",t.fork[0])[0],s=this.N("id",t.fork[1])[0];let e,o;t.rowTemp>0&&(e=this.j(this.L(i.start),this.L(i.end),t.rowTemp-1,t.rowTemp-1,t.grid)),t.rowTemp<t.grid.length-1&&(o=this.j(this.L(s.start),this.L(s.end),t.rowTemp+1,t.rowTemp+1,t.grid)),e||(e=this.D(t.rowTemp,1,t)),o||(o=this.D(t.rowTemp+1,1,t)),i.rowTemp=e,t.grid=this.W(e,this.L(i.start),this.L(i.end),t.grid),s.rowTemp=o,t.grid=this.W(o,this.L(s.start),this.L(s.end),t.grid)}k(t){let i=[...t].map((t=>{let i={id:t.id};for(const s in t.dataset){let e=t.dataset[s].split(" ").length>1?t.dataset[s].split(" "):t.dataset[s];isNaN(e)||(e=parseInt(e)),i[s]=e}return i}));for(const t of i.filter((t=>t.become)).sort(((t,i)=>t.start-i.start)))if(i.includes(t)){const s=this.V(t,i);i.splice(i.indexOf(t),1,s);for(const[t,e]of s.ids.entries())if(t>0){const t=i.findIndex((t=>t.id==e));i.splice(t,1)}}for(let t of i.filter((t=>t.merge)).concat(i.filter((t=>t.split))))t=this.X(t,i);for(const t of i){const s=this.Y(t,i);s.length>1&&(t.related=s)}return i}V(t,i){t={...t};let s={...i.find((i=>i.ids?i.ids.includes(t.become):i.id===t.become))};return s.become&&(s=this.V(s,i)),t.ids=s.ids?[].concat(t.id,s.ids):[].concat(t.id,s.id),t.chain=!0,t.end=s.end,delete t.become,s.merge&&(t.merge=s.merge),s.fork&&(t.fork=s.fork),t}X(t,i){const s=["merge","split"];for(const e of s)t[e]&&0===this.N("id",t[e],i).length&&(t[e]=this.N("ids",t[e],i)[0].id);return t}Y(t,i){let s=[t];return t.fork&&(s=s.concat(this.O("id",t.fork,i))),s=s.concat(this.N("split",t.id,i)),s=s.concat(this.N("merge",t.id,i).filter((i=>t.split!==i.id&&i.end!==t.start))),s=s.concat(this.N("id",t.merge,i).filter((i=>i.start==t.end))),s}N(t,i,s=this.m){return s.filter((s=>!!s[t]&&(Array.isArray(s[t])?s[t].includes(i):s[t]===i)))}O(t,i,s=this.m){if(!i)throw new Error(`Find by values called without values: ${t} ${i}`);let e=[];for(const o of i)e=e.concat(this.N(t,o,s));return e}K(t,i=this.m){for(const i in t)"string"==typeof t[i]&&(t[i]=[t[i]]);for(const i of["all","any","none"])t[i]||(t[i]=[]);return i.filter((i=>t.all.every((t=>i[t]))&&t.none.every((t=>!i[t]))&&t.any.some((t=>i[t]))))}D(t,i,s){if(0===i)return t;const e=Array.from(Array(i),(()=>new Array(this._).fill(!1)));s.grid.splice(t,0,...e);for(const e of s.related.filter((t=>t.rowTemp||t.relativeRows)))void 0===e.rowTemp&&e.relativeRows.hasOwnProperty(s.id)&&(e.rowTemp=e.relativeRows[s.id].row),e.rowTemp>=t&&(e.rowTemp=e.rowTemp+i),e.relativeRows&&e.relativeRows[s.id]&&(e.relativeRows[s.id].row=e.rowTemp,delete e.rowTemp);return t}P(t,i){i.row&&this.U(i.row,this.L(i.start),this.L(i.end),this.p),i.row=t,this.W(t,this.L(i.start),this.L(i.end),this.p)}Z(t,i){i.rowTemp=t,i.grid=this.W(t,this.L(i.start),this.L(i.end),i.grid)}A(t,i,s){let e=s?s.grid:this.p,o=this.j(this.L(t),this.L(i),0,null,e);return o||0===o||(e=this.q(e),o=e.length-1),o}T(t){let i=!1;for("C"==t.id&&(i=!0),i&&console.log(`Group grid: ${this.tt(t.grid)}`),i&&console.log(`Master grid: ${this.tt(this.p)}`);this.p.length<t.grid.length;)this.p=this.q();for(const i of t.related.filter((t=>t.row)))this.U(i.relativeRows[t.id].row,this.L(i.start),this.L(i.end),t.grid);const s=t.row?t.row-t.relativeRows[t.id].row:null;let e=this.it(t.grid,this.p,s);for(;e.row>0&&this.p.length<t.grid.length+e.row;)this.q(),console.log("Adding row to master grid");e=this.it(t.grid,this.p,s);const o=this.p.length+t.grid.length;for(;null==e.row&&!t.row&&this.p.length<o;)this.q();e=this.it(t.grid,this.p,s);const r=this.it(t.grid,this.p,s);null!==s&&!1===e.fit&&(e.alternative=r),i&&console.log(e);for(const i of t.related.filter((t=>t.row)))this.W(i.relativeRows[t.id].row,this.L(i.start),this.L(i.end),t.grid);return e}B(t,i){if(void 0===i&&!t.row)throw new Error(`Cannot force position without a row: ${t.id}`);void 0===i&&(i=t.row),console.log(`Working through group to force insert: ${t.id}.`);const s=1*i-t.relativeRows[t.id].row;if(!t.row){const s=this.st(i,t);console.log(s)}for(const i of t.related.filter((i=>i.relativeRows[t.id].row<t.relativeRows[t.id].row))){const e=1*i.relativeRows[t.id].row+1*s,o=this.st(e,i);console.log(o)}for(const i of t.related.filter((i=>i.relativeRows[t.id].row>t.relativeRows[t.id].row))){const e=1*i.relativeRows[t.id].row+1*s,o=this.st(e,i);console.log(o)}return this.F(t),{fit:!0,row:i-=t.relativeRows[t.id].row,count:t.grid.length}}et(t,i){return i=i.splice(t,0,new Array(this._).fill(!1)),t}F(t){for(const i of t.related.filter((i=>i!==t.id))){const s=this.ot(i,t.id);s?(console.log(`Moving ${i.id} to ${s}.`),this.P(s,i)):console.log(`No better place for ${i.id}`)}}ot(t){let i=0;if(!t.row)return!1;for(const s in t.relativeRows){const e=this.N("id",s)[0];e.row&&(console.log(`${t.id} would like to be at ${e.row+t.relativeRows[s].relative}`),i+=e.row+t.relativeRows[s].relative-t.row)}console.log(`${t.id} is at ${t.row}; preference: ${i}`);return this.j(this.L(t.start),this.L(t.end),i>0?t.row:t.row+i,i>0?t.row+i:t.row)}it(t,i,s=null){let e=0;const o=s;let r=[];if(null!==s&&this.rt(t[0],i[s])){e=1;for(let o=1;o<t.length&&i[s+o]&&this.rt(t[o],i[s+o]);o++)e+=1;return{fit:e===t.length,row:s,count:e,requested:o,log:r}}for(const[n,h]of i.entries())if(this.rt(t[0],h)){s=n,e=1;for(let o=1;o<t.length&&o+s<i.length;o++){const n=this.rt(t[o],i[s+o]);if(n&&r.push(`${o}: Fit ok for row ${s+o}`),!n)break;e+=1}return{fit:e===t.length,row:s,count:e,requested:o}}return{fit:!1,row:null,count:0,requested:o}}rt(t,i){for(const[s,e]of t.entries())if(e&&i[s])return!1;return!0}j(t,i,s=0,e=null,o=this.p){null===e&&(e=o.length-1);for(let r=s;r<=e;r++)if(this.nt(r,t,i,o))return r;return!1}nt(t,i,s,e=this.p){if(i===s&&(s+=1),void 0===e[t])throw new Error(`Invalid row checked. ${t} ${i} ${s}. Highest row: ${e.length-1}`);if(s>e[t].length-1||i<0)throw new Error(`Invalid range checked. ${t} ${i} ${s}. Available range is: 0 - ${e[t].length-1}`);return e[t].slice(i,s).every((t=>!1===t))}get rows(){return this.p.length}v(t){const i=t.filter((t=>t.row)),s=i.length>0?Math.max(...i.map((t=>t.row)))+1:1;let e=Array.from(Array(s),(()=>new Array(this._).fill(!1)));for(const t of i)e=this.W(t.row,this.L(t.start),this.L(t.end),e);return e}J(t){let i=0;for(;i<t.length-1&&this.nt(i,0,t[0].length-1,t);)i++;return t=t.slice(i)}tt(t){return JSON.stringify(t.map((t=>t.filter((t=>t)).length)))}W(t,i,s,e=this.p){return this.ht(t,i,s,!0,e),e}U(t,i,s,e=this.p){return this.ht(t,i,s,!1,e),e}ht(t,i,s,e,o=this.p){if(!o[t])throw new Error(`Attempt to mark non-existent grid row ${t}`);if(i>o[0].length-1||s>o[0].length-1)throw new Error(`X coords out of range: ${i} ${s}`);let r=0;for(;r<s-i;)o[t][i+r]=e,r++;return i>0&&(o[t][i-1]=e),s<o[t].length&&(o[t][s]=e),o}q(t=this.p){return t.push(new Array(this._).fill(!1)),t}st(t,i,s=this.p){let e=Array();return i.row==t?(console.log(`Requested to free row ${t} for ${i.id} but it's already positioned there...`),e):(this.nt(t,this.L(i.start),this.L(i.end),s)||(console.log(`Row ${t} not free for ${i.id}. Shifting.`),e=this.ct(parseInt(t),this.L(i.start),this.L(i.end),s)),e)}ct(t,i,s,e){let o=Array();console.log(`Shift called with: ${t} ${i} ${s}`);const r=this.m.filter((e=>e.row==t&&this.L(e.end)>=i&&this.L(e.start)<=s));console.log("Entries affected:"),console.log(r);for(const i of r){console.log(`${i.id} affected by move at row ${t}`);const s=this.L(i.start),r=this.L(i.end);1*t+1>=e.length&&this.q(e);let n=!1;this.nt(1*t+1,s,r,e)&&(n=!0),!1===n&&(console.log(`Space for ${i.id} was blocked. Continuing...`),o=o.concat(this.ct(1*t+1,s,r,e))),this.P(1*i.row+1,i),o.push(i.id),console.log(`${i.id} moving from ${1*i.row-1} to ${i.row}`)}return o}lt(t,i=this.p){i==this.p&&console.log(`Inserting row in master grid at ${t}`);try{i.splice(t,0,new Array(this._).fill(!1))}catch{throw new Error(`Bad row insert: ${t}, ${count}`)}return i}L(t){if(isNaN(t))throw new Error(`${t} is not a year. Cannot parse as number.`);return parseInt(t)-parseInt(this.$)}}function e(t,i){let s={};for(const e in t)i.hasOwnProperty(e)?s[e]=i[e]:s[e]=t[e];return s}const o={yearStart:1900,yearEnd:(new Date).getFullYear()+1,strokeWidth:4,yearWidth:50,rowHeight:50,padding:5,strokeColour:"#999",boxWidth:100,guides:!0,guideInterval:5,entrySelector:"div",linkDashes:"4",irregularDashes:"88 4 4 4"};class r{constructor(t,i={}){this.dt=this.ut(i),this.ft=document.getElementById(t),this.m=this.ft.querySelectorAll("#"+t+" > "+this.dt.entrySelector+":not(.timeline-exclude)"),this.wt()}wt(){let t=1;for(const i of this.m)if(i.classList.contains("timeline-block")?(i.id="block-"+t,i.dataset.block=!0,t++):(i.classList.add("entry"),i.dataset.entry=!0),i.dataset.end=i.dataset.end?i.dataset.end:this.dt.yearEnd,i.dataset.become&&(i.dataset.end=parseInt(document.getElementById(i.dataset.become).dataset.start)),i.dataset.fork){const t=i.dataset.fork.split(" ");i.dataset.end=Math.max(document.getElementById(t[0]).dataset.start,document.getElementById(t[1]).dataset.start)}}ut(t){const i=e(o,t);return i.boxHeight=i.rowHeight-2*i.padding,i.boxMinWidth=i.boxHeight,i}$t(t,i){this.dt[t]=i}create(){return this.gt=new s(this.m,this.dt.yearStart,this.dt.yearEnd),this.$t("rows",this.gt.rows),this.yt(),this._t(),this.kt(),!0===this.dt.guides&&this.xt(),this.ft}yt(){const t=document.documentElement;t.style.setProperty("--timeline-year-width",this.dt.yearWidth+"px"),t.style.setProperty("--timeline-row-height",this.dt.rowHeight+"px"),t.style.setProperty("--timeline-box-width",this.dt.boxWidth+"px"),t.style.setProperty("--timeline-box-height",this.dt.boxHeight+"px"),t.style.setProperty("--timeline-box-width-min",this.dt.boxHeight+"px"),t.style.setProperty("--timeline-padding",this.dt.padding+"px"),t.style.setProperty("--timeline-stroke-colour",this.dt.strokeColour),this.ft.classList.add("timeline-container"),this.ft.style.height=(this.dt.rows+2)*this.dt.rowHeight+"px",this.ft.style.width=(this.dt.yearEnd+1-this.dt.yearStart)*this.dt.yearWidth+"px",this.vt()}vt(){for(const t of this.m)t.style.left=this.Et(t.dataset.start)+"px",t.style.top=(parseInt(t.dataset.row)+1)*this.dt.rowHeight+this.dt.padding+"px",t.dataset.colour&&(t.style.borderColor=t.dataset.colour),!0===this.bt(t)&&t.classList.add("min");for(const t of[...this.m].filter((t=>t.dataset.become))){const i=document.getElementById(t.dataset.become);t.dataset.start==i.dataset.start&&(t.style.left=parseInt(t.style.left)-this.dt.boxMinWidth/2+"px",i.style.left=parseInt(i.style.left)+this.dt.boxMinWidth/2+"px")}}kt(){const t=document.createElement("div");t.classList.add("dates");let i=this.dt.yearStart;for(;i<this.dt.yearEnd;){const s=document.createElement("date");s.style.left=this.Et(i)+"px";const e=document.createTextNode(i);s.append(e),t.append(s),i+=5}this.ft.prepend(t);const s=t.cloneNode(!0);s.style.top=this.dt.rows*this.dt.rowHeight+"px",this.ft.append(s)}xt(){let t=this.dt.yearStart;for(;t<Math.ceil(this.dt.yearEnd/this.dt.guideInterval)*this.dt.guideInterval;){const i=document.createElement("div");i.classList.add("guide"),i.style.left=this.Et(t)+"px",i.style.width=this.dt.yearWidth*this.dt.guideInterval+"px",(t-this.dt.yearStart)/this.dt.guideInterval%2==1&&i.classList.add("odd"),this.ft.append(i),t+=this.dt.guideInterval}}_t(){for(const t of[...this.m].filter((t=>!t.classList.contains("timeline-block")))){const s=t.dataset.colour?t.dataset.colour:this.dt.strokeColour,e="true"==t.dataset.irregular?this.dt.irregularDashes:"";if(!t.id)throw new Error(`Missing id on ${t.text}`);try{this.Et(t.dataset.end)}catch{console.log(`${t.id} error on draw - bad end year`)}let o="",r="end",n=this.It(t.id,"right"),h={x:this.Et(t.dataset.end),y:n.y};if(t.dataset.merge||t.dataset.fork||t.dataset.become||(o=t.dataset.endEstimate?"dots":"circle"),t.dataset.become&&(h=this.It(t.dataset.become,"left"),r="become"),t.dataset.merge){t.dataset.start==t.dataset.end&&(h.x+=this.dt.yearWidth);const e={x:h.x,y:this.Rt(t.dataset.merge)};h.x=h.x-this.dt.yearWidth;const o=i.draw({start:h,end:e,stroke:this.dt.strokeWidth,colour:s});o.classList.add("merge"),this.ft.append(o),r="merge"}if(t.dataset.start!==t.dataset.end){const t=i.draw({start:n,end:h,stroke:this.dt.strokeWidth,colour:s,markers:["",o],dashes:e});t.classList.add(r),this.ft.append(t)}t.dataset.split&&this.St(t,s),t.dataset.fork&&this.Mt(t,s),t.dataset.links&&this.zt(t,s)}}St(t,s){const e=document.getElementById(t.dataset.split);let o="top";parseInt(t.dataset.row)<parseInt(e.dataset.row)&&(o="bottom");const r={x:this.Et(t.dataset.start),y:this.Rt(e.id)},n=this.It(t.id,o),h=i.draw({start:r,end:n,stroke:this.dt.strokeWidth,colour:s});h.classList.add("split"),this.ft.append(h)}Mt(t,s){const e=t.dataset.fork.split(" "),o=parseInt(t.dataset.end),r={x:this.Et(o),y:this.Rt(t.id)},n={x:this.Et(o+1),y:this.Rt(e[0])},h={x:this.Et(o+1),y:this.Rt(e[1])},c=i.draw({start:r,end:n,stroke:this.dt.strokeWidth,colour:s}),a=i.draw({start:r,end:h,stroke:this.dt.strokeWidth,colour:s});c.classList.add("fork"),a.classList.add("fork"),this.ft.append(c,a)}zt(t,s){const e=t.dataset.links.split(" ");let o={top:-1,bottom:-1,left:-1,right:-1};for(const r of e){const e=document.getElementById(r);e||console.warn(`${t.id} links to non-existant ID ${r}`);let n,h,c={x:0,y:0},a={x:0,y:0};const l=parseInt(t.dataset.row),d=parseInt(e.dataset.row);l===d&&t.dataset.start<e.dataset.start&&(o.right=o.right+1,n="right",h="left"),l===d&&t.dataset.start>e.dataset.start&&(o.left=o.left+1,n="left",h="right"),l>d&&(o.top=o.top+1,n="top",h="bottom"),l<d&&(o.bottom=o.bottom+1,n="bottom",h="top"),c=this.It(t.id,n,o[n]),a={x:c.x,y:this.Rt(e.id)},t.dataset.start>=e.dataset.end&&(a.x=this.Et(e.dataset.end)),t.dataset.start==e.dataset.start&&(a=this.It(e.id,h));const u=i.draw({start:c,end:a,stroke:this.dt.strokeWidth/2,colour:s,markers:["square","square"],dashes:this.dt.linkDashes});u.classList.add("link"),this.ft.append(u)}}bt(t){return(t.dataset.end-t.dataset.start>0?t.dataset.end-t.dataset.start:1)<this.dt.boxWidth/this.dt.yearWidth}Ct(t){const i=document.getElementById(t);return parseFloat(i.style.left)+this.dt.boxWidth/2}Rt(t){const i=document.getElementById(t);return null==i&&console.log(`ID:${t} got null node.`),parseFloat(i.style.top)+this.dt.boxHeight/2}It(t,i,s=0){const e=document.getElementById(t),o=window.getComputedStyle(e),r=parseFloat(e.style.left),n=parseFloat(e.style.top),h=parseFloat(o.getPropertyValue("width")),c=parseFloat(o.getPropertyValue("height"));switch(i){case"left":return{x:r,y:n+c/2+5*s};case"right":return{x:r+h,y:n+c/2+5*s};case"top":return{x:r+h/2+5*s,y:n};case"bottom":return{x:r+h/2+5*s,y:n+c};default:throw`Invalid element side specified: Called with ${i}. Entry: ${t}`}}Et(t){if(isNaN(t))throw new Error(`Non-numerical year value received: ${t}`);return parseInt((t-this.dt.yearStart)*this.dt.yearWidth)}}const n={panzoom:!1,findForm:"timeline-find",zoomIn:"timeline-zoom-in",zoomOut:"timeline-zoom-out",zoomReset:"timeline-zoom-reset"};return class{constructor(t="diagram",i={}){this.ft=t,this.Gt(i)}create(){const t=new r(this.ft,this.Ft);this.Nt=t.create(),!0===this.dt.panzoom&&(this.At(),this.Pt(),window.addEventListener("hashchange",(()=>this.Tt()))),location.hash&&setTimeout((()=>{this.Tt()}))}Gt(t){this.dt=e(n,t),this.Ft=e(o,t)}panToEntry(t){if(!0!==this.dt.panzoom)throw new Error("Panzoom not enabled. Enable Panzoom to use the pan-to-entry feature.");if(void 0===this.qt)throw new Error("Panzoom module missing. Include Panzoom to use the pan-to-entry feature.");const i=document.getElementById(t),s=window.innerWidth/2-parseInt(i.style.left)-this.Ft.boxWidth/2,e=window.innerHeight/2-parseInt(i.style.top)-this.Ft.rowHeight/2;this.qt.zoom(1),this.qt.pan(s,e);const o=new CustomEvent("timelineFind",{detail:{id:t,name:i.innerText}});document.getElementById(this.ft).dispatchEvent(o),setTimeout((()=>{i.classList.add("highlight","hover")}),500),setTimeout((()=>{i.classList.remove("highlight","hover")}),2e3)}Pt(){const t=document.getElementById(this.dt.zoomIn),i=document.getElementById(this.dt.zoomOut),s=document.getElementById(this.dt.zoomReset),e=document.getElementById(this.dt.findForm);t&&t.addEventListener("click",this.qt.zoomIn),i&&i.addEventListener("click",this.qt.zoomOut),s&&s.addEventListener("click",(()=>this.qt.zoom(1))),e&&this.Bt(e)}Bt(t){const i=document.createElement("input");i.name="find-id",i.style.display="none",t.append(i);const s=t.querySelector("input[name=finder]"),e=document.createElement("div"),o=document.createElement("div"),r=document.createElement("ul");e.classList.add("filtered-entries"),e.appendChild(o),o.appendChild(r),s.parentNode.insertBefore(e,s),e.appendChild(s),s.autocomplete="off",o.style.width=s.offsetWidth+"px";const n={form:t,finder:s,id:i,results:r};this.Dt=n,n.finder.value="",t.addEventListener("input",(t=>this.Ot(t))),t.addEventListener("submit",(t=>this.Jt(t))),r.addEventListener("click",(t=>this.Wt(t)))}Ot(t){const i=t.target.value;if(""===i.trim())return void(this.Dt.results.innerHTML="");const s=this.Lt(i),e=this.Dt.results;e.innerHTML="";for(const t of s){const i=document.createElement("li");i.dataset.id=t.id,i.innerText=t.name,e.append(i)}}Lt(t){return[...document.querySelectorAll(".entry")].map((t=>({id:t.id,name:t.innerText}))).filter((i=>i.name.toLowerCase().includes(t.toLowerCase())))}Wt(t){if("li"!==t.target.localName)return null;const i=this.Dt.form,s=this.Dt.finder,e=this.Dt.id;s.value=t.target.innerText,e.value=t.target.dataset.id,i.requestSubmit()}Jt(t){t.preventDefault();const i=t.target.querySelector("input[name=find-id]").value;t.target.querySelector("input[name=finder]").value,document.getElementById(i)&&this.panToEntry(i),this.Dt.results.innerHTML="",this.Dt.finder.value=""}At(){if("undefined"==typeof Panzoom)throw new Error("Missing dependency. External Panzoom library (@panzoom/panzoom) is required to use the panzoom feature.");const t=document.createElement("div");t.classList.add("pz-wrap"),this.Nt.parentNode.insertBefore(t,this.Nt),t.appendChild(this.Nt),this.qt=Panzoom(this.Nt,{contain:"outside",maxScale:3,minScale:.5,step:.1,handleStartEvent:t=>{t.preventDefault()}}),this.Nt.parentElement.addEventListener("wheel",this.qt.zoomWithWheel)}Tt(){const t=location.hash.replace("#find-","");document.getElementById(t)&&this.qt&&this.panToEntry(t)}}}));
